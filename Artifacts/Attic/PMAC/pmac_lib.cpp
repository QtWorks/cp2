//////////////////////////////////////////////////////////////////////
// File - pmac_lib.c
//
// Library for accessing the PMAC card.
// Code was generated by DriverWizard v6.02 - http://www.jungo.com.
// The library accesses the hardware via WinDriver functions.
// 
// Copyright (c) 2003 Jungo Ltd.  http://www.jungo.com
// 
//////////////////////////////////////////////////////////////////////

#include	<stdafx.h>  
#include "../CP2Exec/stdafx.h"

#include <time.h>
#include <sys/types.h>
#include <sys/timeb.h>
#include "pmac_lib.h"

#include "c:/windriver6/include/windrvr_int_thread.h"
#include "c:/windriver6/include/windrvr_events.h"
#include "c:/windriver6/include/status_strings.h"
#ifndef __KERNEL__
	#include <stdio.h>
#endif

// If an error occurs, this string will be set to contain a relevant error message
CHAR PMAC_ErrorString[1024];

// internal data structures
typedef struct
{
    WD_INTERRUPT Int;
    HANDLE hThread;
    PMAC_INT_HANDLER funcIntHandler;
} PMAC_INT_INTERRUPT;

typedef struct
{
    DWORD index;
    BOOL  fIsMemory;
    BOOL  fActive;
} PMAC_ADDR_DESC;

typedef struct PMAC_STRUCT
{
    HANDLE hWD;
    HANDLE hEvent;
    PMAC_INT_INTERRUPT Int;
    WD_PCI_SLOT pciSlot;
    PMAC_ADDR_DESC addrDesc[PMAC_ITEMS];
    WD_CARD_REGISTER cardReg;
} PMAC_STRUCT;

// internal function used by PMAC_Open()
BOOL PMAC_DetectCardElements(PMAC_HANDLE hPMAC);

// Function: PMAC_CountCards()
//   Count the number of PCI cards that meets the given criteria.
// Parameters:
//   hPMAC [in] handle to the card as received from PMAC_Open().
//   dwVendorID [in] indicates the vendor ID of the PCI card to search.
//     0 indicates all vendor IDs.
//   dwDeviceID [in] indicates the Device ID of the PCI card to search.
//     0 indicates all device IDs.
// Return Value:
//   the number of PCI cards found.
DWORD PMAC_CountCards (DWORD dwVendorID, DWORD dwDeviceID)
{
    WD_VERSION ver;
    WD_PCI_SCAN_CARDS pciScan;
    HANDLE hWD = INVALID_HANDLE_VALUE;
    DWORD dwStatus;

    PMAC_RegisterWinDriver();

    PMAC_ErrorString[0] = '\0';
    hWD = WD_Open();

    // Verify that the handle is valid and that the version number is correct
    if (hWD==INVALID_HANDLE_VALUE) 
    {
        sprintf(PMAC_ErrorString, "Failed opening WinDriver device\n");
        return 0;
    }

    BZERO(ver);
    WD_Version(hWD,&ver);
    if (ver.dwVer<WD_VER) 
    {
        sprintf(PMAC_ErrorString, "Incorrect WinDriver version. Expected %d.%02d, got %d.%02d\n",
             WD_VER/100, WD_VER, ver.dwVer/100, ver.dwVer);
        WD_Close(hWD);
        return 0;
    }

    BZERO(pciScan);
    pciScan.searchId.dwVendorId = dwVendorID;
    pciScan.searchId.dwDeviceId = dwDeviceID;
    dwStatus = WD_PciScanCards (hWD, &pciScan);
    WD_Close (hWD);
    if (dwStatus)
    {
        sprintf(PMAC_ErrorString, "WD_PciScanCards() failed with status 0x%x - %s\n",
            dwStatus, Stat2Str(dwStatus));
    }
    else if (pciScan.dwCards==0)
        sprintf(PMAC_ErrorString, "no cards found\n");
    return pciScan.dwCards;
}

// Function: PMAC_Open()
//   Register a PCI card that meets the given criteria to enable working with it.
//   The handle returned from this function is used by most of the functions in this file.
// Parameters:
//   phPMAC [out] returns the handle to the opened card.
//   dwVendorID [in] indicates the vendor ID of the PCI card to open.
//     0 indicates all vendor IDs.
//   dwDeviceID [in] indicates the device ID of the PCI card to open.
//     0 indicates all device IDs.
//   nCardNum [in] indicates the index number of the PCI card that meets
//     the criteria of the given vendor and device ID.
// Return Value:
//   TRUE if the card was opened successfully. FALSE if there were any errors.
BOOL PMAC_Open (PMAC_HANDLE *phPMAC, DWORD dwVendorID, DWORD dwDeviceID, DWORD nCardNum)
{
    PMAC_HANDLE hPMAC = (PMAC_HANDLE)malloc(sizeof(PMAC_STRUCT));

    WD_VERSION ver;
    DWORD dwStatus;
    WD_PCI_SCAN_CARDS pciScan;
    WD_PCI_CARD_INFO pciCardInfo;

    *phPMAC = NULL;
    PMAC_ErrorString[0] = '\0';
    if (!hPMAC)
    {
        sprintf(PMAC_ErrorString, "Failed allocating memory\n");
        return FALSE;
    }
    BZERO(*hPMAC);

    PMAC_RegisterWinDriver();

    hPMAC->hWD = WD_Open();

    // Verify that the handle is valid and that the version number is correct
    if (hPMAC->hWD==INVALID_HANDLE_VALUE)
    {
        sprintf(PMAC_ErrorString, "Failed opening WinDriver device\n");
        goto Exit;
    }

    BZERO(ver);
    WD_Version(hPMAC->hWD,&ver);
    if (ver.dwVer<WD_VER)
    {
        sprintf(PMAC_ErrorString, "Incorrect WinDriver version. Expected %d.%02d, got %d.%02d\n",
             WD_VER/100, WD_VER, ver.dwVer/100, ver.dwVer);
        goto Exit;
    }

    BZERO(pciScan);
    pciScan.searchId.dwVendorId = dwVendorID;
    pciScan.searchId.dwDeviceId = dwDeviceID;
    dwStatus = WD_PciScanCards(hPMAC->hWD, &pciScan);
    if (dwStatus)
    {
        sprintf(PMAC_ErrorString, "WD_PciScanCards() failed with status 0x%x - %s\n",
            dwStatus, Stat2Str(dwStatus));
        goto Exit;
    }
    if (pciScan.dwCards==0)
    {
        sprintf(PMAC_ErrorString, "Could not find PCI card\n");
        goto Exit;
    }
    if (pciScan.dwCards<=nCardNum)
    {
        sprintf(PMAC_ErrorString, "Card is out of range of available cards\n");
        goto Exit;
    }
    // Found at least one card
    BZERO(pciCardInfo);
    pciCardInfo.pciSlot = pciScan.cardSlot[nCardNum];
    dwStatus = WD_PciGetCardInfo(hPMAC->hWD, &pciCardInfo);
    if (dwStatus)
    {
        sprintf(PMAC_ErrorString, "WD_PciGetCardInfo() failed with status 0x%x - %s\n",
            dwStatus, Stat2Str(dwStatus));
        goto Exit;
    }
    hPMAC->pciSlot = pciCardInfo.pciSlot;
    hPMAC->cardReg.Card = pciCardInfo.Card;

    hPMAC->cardReg.fCheckLockOnly = FALSE;
    dwStatus = WD_CardRegister(hPMAC->hWD, &hPMAC->cardReg);
    if (dwStatus)
    {
        sprintf(PMAC_ErrorString, "Failed locking device. Status 0x%x - %s\n",
            dwStatus, Stat2Str(dwStatus));
        goto Exit;
    }

    if (!PMAC_DetectCardElements(hPMAC))
    {
        sprintf (PMAC_ErrorString, "Card does not have all items expected for PMAC\n");
        goto Exit;
    }

    // PMAC_Open() was successful
    *phPMAC = hPMAC;
    return TRUE;

Exit:
printf("PMAC_ErrorString %s\n", PMAC_ErrorString); 
    // An error occured during the execution of PMAC_Open()
    if (hPMAC->cardReg.hCard) 
        WD_CardUnregister(hPMAC->hWD, &hPMAC->cardReg);
    if (hPMAC->hWD!=INVALID_HANDLE_VALUE)
        WD_Close(hPMAC->hWD);
    free (hPMAC);
    return FALSE;
}

// Function: PMAC_Close()
//   Unregister an opened card.
// Parameters:
//   hPMAC [in] handle to the card as received from PMAC_Open().
// Return Value:
//   None.
void PMAC_Close(PMAC_HANDLE hPMAC)
{
    // disable interrupts
    if (PMAC_IntIsEnabled(hPMAC))
        PMAC_IntDisable(hPMAC);

    // unregister card
    if (hPMAC->cardReg.hCard) 
        WD_CardUnregister(hPMAC->hWD, &hPMAC->cardReg);

    // close WinDriver
    WD_Close(hPMAC->hWD);

    free (hPMAC);
}

// Function: PMAC_RegisterWinDriver()
//   Enter a license string into WinDriver module.
// Parameters:
//   None.
// Return Value:
//   None.
void PMAC_RegisterWinDriver()
{
    HANDLE hWD;
    WD_LICENSE lic;

    hWD = WD_Open();
    if (hWD!=INVALID_HANDLE_VALUE)
    {
//!         strcpy(lic.cLicense, "6c3cda80693a5b3a73de254669e59be727ce2f79.Binet"); // comm'l license
strcpy(lic.cLicense, "6c3cda80693a5b3a738e9f330873b005dfb26f5d.Binet"); // academic license
         WD_License(hWD, &lic);
         WD_Close(hWD);
		printf("WD_Open() returned hWD = 0x%x\n", hWD);
    }
	else
		printf("WD_Open() returned INVALID_HANDLE_VALUE\n");
}

// Function: PMAC_WritePCIReg()
//   Write a DWORD to the PCI configuration space.
// Parameters:
//   hPMAC [in] handle to the card as received from PMAC_Open().
//   dwReg [in] offset of the register in the PCI configuration space.
//     dwData [in] the value to write into the register.
// Return Value:
//   None.
void PMAC_WritePCIReg(PMAC_HANDLE hPMAC, DWORD dwReg, DWORD dwData)
{
    WD_PCI_CONFIG_DUMP pciCnf;

    BZERO(pciCnf);
    pciCnf.pciSlot = hPMAC->pciSlot;
    pciCnf.pBuffer = &dwData;
    pciCnf.dwOffset = dwReg;
    pciCnf.dwBytes = 4;
    pciCnf.fIsRead = FALSE;
    WD_PciConfigDump(hPMAC->hWD,&pciCnf);
}

// Function: PMAC_ReadPCIReg()
//   Read a DWORD from the PCI configuration space.
// Parameters:
//   hPMAC [in] handle to the card as received from PMAC_Open().
//   dwReg [in] offset of the register in the PCI configuration space.
// Return Value:
//   the value of the register.
DWORD PMAC_ReadPCIReg(PMAC_HANDLE hPMAC, DWORD dwReg)
{
    WD_PCI_CONFIG_DUMP pciCnf;
    DWORD dwVal;

    BZERO(pciCnf);
    pciCnf.pciSlot = hPMAC->pciSlot;
    pciCnf.pBuffer = &dwVal;
    pciCnf.dwOffset = dwReg;
    pciCnf.dwBytes = 4;
    pciCnf.fIsRead = TRUE;
    WD_PciConfigDump(hPMAC->hWD,&pciCnf);
    return dwVal;
}

BOOL PMAC_DetectCardElements(PMAC_HANDLE hPMAC)
{
    DWORD i;
    DWORD ad_sp;

    BZERO(hPMAC->Int);
    BZERO(hPMAC->addrDesc);

    for (i=0; i<hPMAC->cardReg.Card.dwItems; i++)
    {
        WD_ITEMS *pItem = &hPMAC->cardReg.Card.Item[i];

        switch (pItem->item)
        {
        case ITEM_MEMORY:
            ad_sp = pItem->I.Mem.dwBar;
            hPMAC->addrDesc[ad_sp].fIsMemory = TRUE;
            hPMAC->addrDesc[ad_sp].fActive = TRUE;
            hPMAC->addrDesc[ad_sp].index = i;
            break;
        case ITEM_IO:
            ad_sp = pItem->I.IO.dwBar;
            hPMAC->addrDesc[ad_sp].fIsMemory = FALSE;
            hPMAC->addrDesc[ad_sp].fActive = TRUE;
            hPMAC->addrDesc[ad_sp].index = i;
            break;
        case ITEM_INTERRUPT:
            if (hPMAC->Int.Int.hInterrupt) return FALSE;
            hPMAC->Int.Int.hInterrupt = pItem->I.Int.hInterrupt;
            break;
        }
    }

    // Verify that all the necessary items were found
    // Verify that an interrupt was found
    if (!hPMAC->Int.Int.hInterrupt) 
        return FALSE;

    // Verify that at least one memory/IO space was found
    for (i = 0; i<PMAC_ITEMS; i++)
        if (PMAC_IsAddrSpaceActive(hPMAC, (PMAC_ADDR) i)) break;
    if (i==PMAC_ITEMS) return FALSE;

    return TRUE;
}

// Function: PMAC_IsAddrSpaceActive()
//   Check if the given address space is configured and active.
// Parameters:
//   hPMAC [in] handle to the card as received from PMAC_Open().
//   addrSpace [in] the address space to check.
// Return Value:
//   TRUE if the address space is active. FALSE otherwise.
BOOL PMAC_IsAddrSpaceActive(PMAC_HANDLE hPMAC, PMAC_ADDR addrSpace)
{
    return hPMAC->addrDesc[addrSpace].fActive;
}

// Function: PMAC_GetPciSlot()
//   Return the logical location (bus, slot and function) of the PCI card.
// Parameters:
//   hPMAC [in] handle to the card as received from PMAC_Open().
//   pPciSlot [out] - pointer to a caller allocated space that will hold the
//     logical location of the card
// Return Value:
//   None.
void PMAC_GetPciSlot(PMAC_HANDLE hPMAC, WD_PCI_SLOT *pPciSlot)
{
    memcpy((PVOID)pPciSlot, &(hPMAC->pciSlot), sizeof(WD_PCI_SLOT));
}

// General read/write functions

// Function: PMAC_ReadWriteBlock()
//   Read/Write data from/to the card's memory/IO into/from a given buffer.
// Parameters:
//   hPMAC [in] handle to the card as received from PMAC_Open().
//   addrSpace [in] the address space of the card to access.
//   dwOffset [in] offset relative to the beginning of the address space to access.
//   fRead [in] direction of operation:
//     TRUE indicates read from the card's memory/IO into the given buffer.
//     FALSE indicates write from the given buffer to the card's memory/IO.
//   buf [in/out] a caller allocated buffer to read/write to/from.
//   dwBytes [in] the number of bytes to read/write. The allocated buffer should be at least dwBytes long.
//   mode [in] perform the data transfer byte by byte / word by word / dword by dword.
// Return Value:
//   None.
void PMAC_ReadWriteBlock(PMAC_HANDLE hPMAC, PMAC_ADDR addrSpace,
    DWORD dwOffset, BOOL fRead, PVOID buf, DWORD dwBytes, PMAC_MODE mode)
{
    WD_TRANSFER trans;
    BOOL fMem = hPMAC->addrDesc[addrSpace].fIsMemory;
    // safety check: is the address range active
    if (!PMAC_IsAddrSpaceActive(hPMAC, addrSpace)) return;
    BZERO(trans);
    if (fRead)
    {
        if (mode==PMAC_MODE_BYTE) trans.cmdTrans = fMem ? RM_SBYTE : RP_SBYTE;
        else if (mode==PMAC_MODE_WORD) trans.cmdTrans = fMem ? RM_SWORD : RP_SWORD;
        else if (mode==PMAC_MODE_DWORD) trans.cmdTrans = fMem ? RM_SDWORD : RP_SDWORD;
    }
    else
    {
        if (mode==PMAC_MODE_BYTE) trans.cmdTrans = fMem ? WM_SBYTE : WP_SBYTE;
        else if (mode==PMAC_MODE_WORD) trans.cmdTrans = fMem ? WM_SWORD : WP_SWORD;
        else if (mode==PMAC_MODE_DWORD) trans.cmdTrans = fMem ? WM_SDWORD : WP_SDWORD;
    }
    if (fMem)
        trans.dwPort = hPMAC->cardReg.Card.Item[hPMAC->addrDesc[addrSpace].index].I.Mem.dwTransAddr;
    else trans.dwPort = hPMAC->cardReg.Card.Item[hPMAC->addrDesc[addrSpace].index].I.IO.dwAddr;
    trans.dwPort += dwOffset;

    trans.fAutoinc = TRUE;
    trans.dwBytes = dwBytes;
    trans.dwOptions = 0;
    trans.Data.pBuffer = buf;
    WD_Transfer (hPMAC->hWD, &trans);
}

// Function: PMAC_ReadByte()
//   Read a Byte from the card's memory/IO.
// Parameters:
//   hPMAC [in] handle to the card as received from PMAC_Open().
//   addrSpace [in] the address space of the card to access.
//   dwOffset [in] offset relative to the beginning of the address space to access.
// Return Value:
//   The value read from the card's memory/IO.
BYTE PMAC_ReadByte (PMAC_HANDLE hPMAC, PMAC_ADDR addrSpace, DWORD dwOffset)
{
    BYTE data;
    if (hPMAC->addrDesc[addrSpace].fIsMemory)
    {
        PBYTE pData = (PBYTE) (hPMAC->cardReg.Card.Item[hPMAC->addrDesc[addrSpace].index].I.Mem.dwUserDirectAddr + dwOffset);
        data = *pData; // read directly from the memory mapped range
    }
    else PMAC_ReadWriteBlock(hPMAC, addrSpace, dwOffset, TRUE, &data, sizeof(BYTE), PMAC_MODE_BYTE);
    return data;
}

// Function: PMAC_ReadWord()
//   Read a Word from the card's memory/IO.
// Parameters:
//   hPMAC [in] handle to the card as received from PMAC_Open().
//   addrSpace [in] the address space of the card to access.
//   dwOffset [in] offset relative to the beginning of the address space to access.
// Return Value:
//   The value read from the card's memory/IO.
WORD PMAC_ReadWord (PMAC_HANDLE hPMAC, PMAC_ADDR addrSpace, DWORD dwOffset)
{
    WORD data;
    if (hPMAC->addrDesc[addrSpace].fIsMemory)
    {
        PWORD pData = (PWORD) (hPMAC->cardReg.Card.Item[hPMAC->addrDesc[addrSpace].index].I.Mem.dwUserDirectAddr + dwOffset);
        data = *pData; // read directly from the memory mapped range
    }
    else PMAC_ReadWriteBlock(hPMAC, addrSpace, dwOffset, TRUE, &data, sizeof(WORD), PMAC_MODE_WORD);
    return data;
}

// Function: PMAC_ReadDword()
//   Read a Dword from the card's memory/IO.
// Parameters:
//   hPMAC [in] handle to the card as received from PMAC_Open().
//   addrSpace [in] the address space of the card to access.
//   dwOffset [in] offset relative to the beginning of the address space to access.
// Return Value:
//   The value read from the card's memory/IO.
DWORD PMAC_ReadDword (PMAC_HANDLE hPMAC, PMAC_ADDR addrSpace, DWORD dwOffset)
{
    DWORD data;
    if (hPMAC->addrDesc[addrSpace].fIsMemory)
    {
        PDWORD pData = (PDWORD) (hPMAC->cardReg.Card.Item[hPMAC->addrDesc[addrSpace].index].I.Mem.dwUserDirectAddr + dwOffset);
        data = *pData; // read directly from the memory mapped range
    }
    else PMAC_ReadWriteBlock(hPMAC, addrSpace, dwOffset, TRUE, &data, sizeof(DWORD), PMAC_MODE_DWORD);
    return data;
}

// Function: PMAC_WriteByte()
//   Write a Byte to the card's memory/IO.
// Parameters:
//   hPMAC [in] handle to the card as received from PMAC_Open().
//   addrSpace [in] the address space of the card to access.
//   dwOffset [in] offset relative to the beginning of the address space to access.
//   data [in] the data to write to the card's memory/IO.
// Return Value:
//   None.
void PMAC_WriteByte (PMAC_HANDLE hPMAC, PMAC_ADDR addrSpace, DWORD dwOffset, BYTE data)
{
    if (hPMAC->addrDesc[addrSpace].fIsMemory)
    {
        PBYTE pData = (PBYTE) (hPMAC->cardReg.Card.Item[hPMAC->addrDesc[addrSpace].index].I.Mem.dwUserDirectAddr + dwOffset);
        *pData = data; // write directly to the memory mapped range
    }
    else PMAC_ReadWriteBlock(hPMAC, addrSpace, dwOffset, FALSE, &data, sizeof(BYTE), PMAC_MODE_BYTE);
}

// Function: PMAC_WriteWord()
//   Write a Word to the card's memory/IO.
// Parameters:
//   hPMAC [in] handle to the card as received from PMAC_Open().
//   addrSpace [in] the address space of the card to access.
//   dwOffset [in] offset relative to the beginning of the address space to access.
//   data [in] the data to write to the card's memory/IO.
// Return Value:
//   None.
void PMAC_WriteWord (PMAC_HANDLE hPMAC, PMAC_ADDR addrSpace, DWORD dwOffset, WORD data)
{
    if (hPMAC->addrDesc[addrSpace].fIsMemory)
    {
        PWORD pData = (PWORD) (hPMAC->cardReg.Card.Item[hPMAC->addrDesc[addrSpace].index].I.Mem.dwUserDirectAddr + dwOffset);
        *pData = data; // write directly to the memory mapped range
    }
    else PMAC_ReadWriteBlock(hPMAC, addrSpace, dwOffset, FALSE, &data, sizeof(WORD), PMAC_MODE_WORD);
}

// Function: PMAC_WriteDword()
//   Write a Dword to the card's memory/IO.
// Parameters:
//   hPMAC [in] handle to the card as received from PMAC_Open().
//   addrSpace [in] the address space of the card to access.
//   dwOffset [in] offset relative to the beginning of the address space to access.
//   data [in] the data to write to the card's memory/IO.
// Return Value:
//   None.
void PMAC_WriteDword (PMAC_HANDLE hPMAC, PMAC_ADDR addrSpace, DWORD dwOffset, DWORD data)
{
    if (hPMAC->addrDesc[addrSpace].fIsMemory)
    {
        PDWORD pData = (PDWORD) (hPMAC->cardReg.Card.Item[hPMAC->addrDesc[addrSpace].index].I.Mem.dwUserDirectAddr + dwOffset);
        *pData = data; // write directly to the memory mapped range
    }
    else PMAC_ReadWriteBlock(hPMAC, addrSpace, dwOffset, FALSE, &data, sizeof(DWORD), PMAC_MODE_DWORD);
}

// Function: PMAC_IntIsEnabled()
//   Check if the interrupt is enabled.
// Parameters:
//   hPMAC [in] handle to the card as received from PMAC_Open().
// Return Value:
//   TRUE if the interrupt is enabled. FALSE otherwise.
BOOL PMAC_IntIsEnabled (PMAC_HANDLE hPMAC)
{
    if (!hPMAC->Int.hThread) return FALSE;
    return TRUE;
}

void PMAC_IntHandler (PVOID pData)
{
    PMAC_HANDLE hPMAC = (PMAC_HANDLE) pData;
    PMAC_INT_RESULT intResult;
    intResult.dwCounter = hPMAC->Int.Int.dwCounter;
    intResult.dwLost = hPMAC->Int.Int.dwLost;
    intResult.fStopped = hPMAC->Int.Int.fStopped;
    hPMAC->Int.funcIntHandler(hPMAC, &intResult);
}

// Function: PMAC_IntEnable()
//   Enable the interrupt.
// Parameters:
//   hPMAC [in] handle to the card as received from PMAC_Open.
//   funcIntHandler [in] The call back function to be called upon interrupt.
// Return Value:
//   TRUE if the interrupt was successfully enabled. FALSE otherwise.
BOOL PMAC_IntEnable (PMAC_HANDLE hPMAC, PMAC_INT_HANDLER funcIntHandler)
{
    DWORD dwStatus;

    // Check if interrupt is already enabled
    if (hPMAC->Int.hThread)
        return FALSE;

    // Calls WD_IntEnable() and creates an interrupt handler thread
    hPMAC->Int.funcIntHandler = funcIntHandler;
    dwStatus = InterruptEnable(&hPMAC->Int.hThread, hPMAC->hWD, &hPMAC->Int.Int, PMAC_IntHandler, (PVOID) hPMAC);
    if (dwStatus)
    {
        sprintf(PMAC_ErrorString, "InterruptEnable() failed with status 0x%x - %s\n",
            dwStatus, Stat2Str(dwStatus));
        return FALSE;
    }

    return TRUE;
}

// Function: PMAC_IntDisable()
//   Disable the interrupt.
// Parameters:
//   hPMAC [in] handle to the card as received from PMAC_Open().
// Return Value:
//   None.
void PMAC_IntDisable (PMAC_HANDLE hPMAC)
{
    if (!hPMAC->Int.hThread) return;

    // this calls WD_IntDisable()
    InterruptDisable(hPMAC->Int.hThread);

    hPMAC->Int.hThread = NULL;
}

// Function: PMAC_RegisterEvent()
//   Register to receive Plug-and-Play and power notification events according to the given criteria.
// Parameters:
//   hPMAC [in] handle to the PCI card as received from PMAC_Open().
//   dwAction [in] bit-field data that indicated on what type of actions to be notified.
//   dwVendorID [in] indicates the vendor ID of the PCI card to register events upon.
//     0 indicates all vendor IDs.
//   dwDeviceID [in] indicates the device ID of the PCI card to register events upon.
//     0 indicates all device IDs.
//   pciSlot [in] indicates the logical location (bus, lot and function) of the PCI card
//     to register events upon. 0 indicates all
//   funcHandler [in] the call back function to be called when event is received.
// Return Value:
//   TRUE is the registration was successful. FALSE otherwise.
BOOL PMAC_RegisterEvent(PMAC_HANDLE hPMAC, DWORD dwAction, DWORD dwVendorID, DWORD dwDeviceID,
    WD_PCI_SLOT pciSlot, EVENT_HANDLER funcHandler)
{
    HANDLE hEvent;
    WD_EVENT Events;    DWORD dwStatus;

    BZERO(Events);
    Events.dwCardType = WD_BUS_PCI;
    Events.u.Pci.pciSlot = pciSlot;
    Events.u.Pci.cardId.dwVendorId = dwVendorID;
    Events.u.Pci.cardId.dwDeviceId = dwDeviceID;
    Events.dwAction = dwAction;
    dwStatus = EventRegister(&hEvent, hPMAC->hWD, &Events, funcHandler, NULL);
    if (dwStatus)
    {
        sprintf(PMAC_ErrorString, "EventRegister() failed with status 0x%x - %s\n",
            dwStatus, Stat2Str(dwStatus));
        return FALSE;
    }
    hPMAC->hEvent = hEvent;
    return TRUE;
}

// Function: PMAC_UnregisterEvent()
//   Unregister events notification.
// Parameters:
//   hPMAC [in] handle to the PCI card as received from PMAC_Open().
// Return Value:
//   None.
void PMAC_UnregisterEvent(PMAC_HANDLE hPMAC)
{
    if (hPMAC->hEvent)
        EventUnregister(hPMAC->hEvent);
}


// Returns a pointer to the PMAC base address
unsigned long *PMAC_GetBasePtr(PMAC_HANDLE hPMAC,PMAC_ADDR addrSpace)
{
	return((unsigned long *)hPMAC->cardReg.Card.Item[hPMAC->addrDesc[addrSpace].index].I.Mem.dwUserDirectAddr);
}

// Returns a pointer to the PMAC physical base address
unsigned long *PMAC_GetBasePtrPhysical(PMAC_HANDLE hPMAC,PMAC_ADDR addrSpace)
{
//	test using physical address: dwCpuPhysicalAddr
//	return((unsigned long *)hPMAC->cardReg.Card.Item[hPMAC->addrDesc[addrSpace].index].I.Mem.dwCpuPhysicalAddr);
//	test using physical address: dwPhysicalAddr
	return((unsigned long *)hPMAC->cardReg.Card.Item[hPMAC->addrDesc[addrSpace].index].I.Mem.dwPhysicalAddr);
	//	returned addresses equal in both cases. 
}

// array of structures containing PMAC DPRAM data and associated quantities required to interpolate angle 
// from packet beamnumber
#define PMACDPRAMDataSize 2048
struct {
	__int64  acquire_time; // time at end of acquisition interval 
	float az_avg; // average azimuth, this interval 
	float el_avg; // average elevation
	unsigned short scan_type; 
	unsigned short sweep; 
	unsigned short volume; 
	unsigned short whatsit; 
	unsigned short transition; 
	unsigned short points; // #samples this average
	float avg_az_sweep_rate; // sweep rate, over previous ~200mSec 
	float avg_el_sweep_rate; // sweep rate, over previous ~200mSec 
} PMACDPRAMData[PMACDPRAMDataSize]; 

// PMAC stuff 
#define INTERP_START_LATENCY	250		// milliseconds before angle data sufficient to begin interpolation 
#define LATENCY_SWEEP_RATE		0.001	// very small
//#define ANGLE_AVERAGE_MSEC		200		// interval for computing average sweep rate for az, el 
#define SWEEP_AVERAGE_MSEC		 70		// interval for computing average sweep rate for az, el 
#define FIRST_INTERP_STEP		12		// step back in PMAC timeseries buffer to get 1st interpolation data point 
static  unsigned short    *Dpram=0;       // for reading PMAC 
static PMAC_HANDLE pmac_handl; 
static float az, el;
static float last_az, delta_az; 
static float az_sum, az_avg, az_interp; 
static float delta_el; 
static float el_sum, el_avg, el_interp; 
static float last_ai, last_ei; // previous interpolated angles and diffs
static float daI, deI; 
static unsigned int angle_samples = 0; // total samples taken
static _int64 BeginEpochMillisec; // start of PMAC data acquisition 
static _int64 SearchEpochMillisec; // start of PMAC data acquisition 
static unsigned int PMACDPRAMDataidx = 0; 
static int PMACDPRAMDataFirstTime = TRUE; 
static int SearchPMACDPRAMDataidx = 0; // search forward from previous find; begin at zero 
static int SearchPMACDPRAMDataacqidx; 
static int FirstPMACDPRAMInterpidx, SecondPMACDPRAMInterpidx; // begin, end entries for interpolation 
static int firstInterpolation = FALSE; 
static unsigned short millisec; 

unsigned int test_az = 0;	//	test data to place in az

struct _timeb PMACtimebuffer;
int b0 = 0; // diagnostic beam accumulations; printed and cleared once per second. 
int b1 = 0; 
int b2 = 0; 
// !note: if interpolate == FALSE, pkt not valid so do not use it. 
int pmac_WD6_acquire(PMAC_HANDLE pmac, PACKET * pkt, int interpolate) { 
	int  size;
	unsigned short * bp_data;
	unsigned short scan_type, sweep, volume, transition; 
	static int i =0;
	static int n =0;

	// method using pointer to PMAC DPRAM from WD6, set in PIRAQ mailbox3: 
	//az = (*(PMACDPRAM)) * 360/65536.0; 
	//printf("PIRAQ pointer az = %5.2f\n",az);

	// method using Windriver6:    
	//    Open the PMAC: 
	//    if(!pmac_handl)
	//		PMAC_Open(&pmac_handl,PMAC_DEFAULT_VENDOR_ID,PMAC_DEFAULT_DEVICE_ID,0);

	//   dwell->header.az = (PMAC_ReadWord(pmac,0,0)) * 360/65536.0;//i++%360;//Dpram[0] * 360.0 / 65536.0;
	//   dwell->header.el = (PMAC_ReadWord(pmac,0,2)) * 360/65536.0;//i++%360;//Dpram[1] * 360.0 / 65536.0;

	//   az = (PMAC_ReadWord(pmac,0,0)) * 360/65536.0; 
	//printf("PMAC_ReadWord az = %5.2f\n",az);

	if (PMACDPRAMDataFirstTime == TRUE) { // first PMAC DPRAM data acquisition
		_ftime( &PMACtimebuffer ); millisec = PMACtimebuffer.millitm; 
		BeginEpochMillisec = (PMACtimebuffer.time * (__int64)1000) + (__int64)PMACtimebuffer.millitm; 
		printf("BeginEpochMillisec =  %I64d\n", BeginEpochMillisec); 
		PMACDPRAMDataFirstTime = FALSE; 
	}
#if 1 // turn on to get az displayed direct from PMAC
	bp_data = (unsigned short *)PMAC_GetBasePtr(pmac, 0); // az offset 0
	PMAC_WriteWord(pmac,0,0,test_az);	//	write something unique each pass to scan_type offset: 
	test_az++;
	az = bp_data[0] * (360/65536.0); 
	printf("bp_data az = %5.2f\n",az);

	az = (PMAC_ReadWord(pmac,0,0)) * 360/65536.0;  
	//printf("PMAC = 0x%x az = %5.2f laz = %5.2f\n", PMAC_ReadWord(pmac,0,0), az, last_az);
	//printf("n = %d after 1 PMAC_ReadWord(pmac,0,0)\n", n); n++; 
	el = (PMAC_ReadWord(pmac,0,2)) * 360/65536.0;
	//printf("n = %d\n", n); n++; 
#endif
	scan_type = PMAC_ReadWord(pmac,0,4);
	sweep = PMAC_ReadWord(pmac,0,6);
	volume = PMAC_ReadWord(pmac,0,8);
	size = PMAC_ReadWord(pmac,0,10);
	transition = PMAC_ReadWord(pmac,0,12);
	// for mSec-resolution time tests: 
	_ftime( &PMACtimebuffer ); millisec = PMACtimebuffer.millitm; 
	if (interpolate == TRUE) {
		RadarEpochMillisec = (__int64)(fpExactmSecperBeam * ((double)pkt->data.info.beam_num) + fpRadarSystemCorrection); // time packet acquired, by beamnumber 
		//!!!		RadarEpochMillisec = ((__int64)mSecperBeam) * pkt->data.info.beam_num; // time packet acquired, by beamnumber 
		//printf("n = %d interpolate == TRUE\n", n); n++; 
		RadarEpochMillisec += (__int64)(TimerStartCorrection); // compensate for timer board startup interval
		if (pkt->data.info.channel == 0) // accumulate beam count for each board 
			b0++; 
		else if (pkt->data.info.channel == 1) 
			b1++; 
		else if (pkt->data.info.channel == 2)
			b2++; 
		//printf("n = %d interpolate == TRUE\n", n); n++; 
	}  
	//printf("RadarEpochMillisec = %I64d \nSystemEpochMillisec = %I64d\n", RadarEpochMillisec, SystemEpochMillisec); 
	//	timeline = ctime( & ( timebuffer.time ) );
	//	if (((az - last_az) > 90.0) || ((az - last_az) < -90.0))
	//		printf("az = %4.3f last_az = %4.3f\n", az, last_az); 

	// print board# here: 
	//printf( "b=%d:\nS=%I64d mSec=%hu last_mSec=%hu d_mSec=%d az_avg=%4.3f el_avg=%4.3f n=%d idx=%d\nR=%I64d BN=%I64d\n", pkt->data.info.channel, SystemEpochMillisec, timebuffer.millitm, last_millisec, delta_millisec, az_avg, el_avg, PMAC_acquire_times, PMACDPRAMDataidx, RadarEpochMillisec, pkt->data.info.beam_num); 
	// print board# above: 
	//printf( "S=%I64d mSec=%hu last_mSec=%hu d_mSec=%d az_avg=%4.3f el_avg=%4.3f n=%d idx=%d\nR=%I64d BN=%I64d\n", SystemEpochMillisec, timebuffer.millitm, last_millisec, delta_millisec, az_avg, el_avg, PMAC_acquire_times, PMACDPRAMDataidx, RadarEpochMillisec, pkt->data.info.beam_num); 

	if (last_millisec != millisec) { 
		//printf("n = %d last_millisec != millisec\n", n); n++; 
		//		printf( "az = %5.2f el = %5.2f scan=%d sweep=%d volume=%d transition=%d mSec=%hu last_mSec=%hu n=%d\n", az, el, scan_type, sweep, volume, transition, timebuffer.millitm, last_millisec, PMAC_acquire_times); 
		//		printf( "az = %5.2f el = %5.2f scan=%d sweep=%d volume=%d transition=%d mSec=%hu last_mSec=%hu n=%d\n", az, el, scan_type, sweep, volume, transition, timebuffer.millitm, last_millisec, PMAC_acquire_times); 
		if (millisec > last_millisec) 
			delta_millisec = millisec - last_millisec; 
		else { // system seconds rollover
			delta_millisec = (millisec + 1000) - last_millisec; 
			printf("beam count: b0 = %d b1 = %d b2 = %d\n", b0, b1, b2); b0 = b1 = b2 = 0; // print accumulations; clear 

		}
		//printf("n = %d last_millisec != millisec\n", n); n++; 
		if (interpolate == TRUE) {
			RadarEpochMillisec = (__int64)(fpExactmSecperBeam * ((double)pkt->data.info.beam_num) + fpRadarSystemCorrection); // time packet acquired, by beamnumber 
			//!!!			RadarEpochMillisec = ((__int64)mSecperBeam) * pkt->data.info.beam_num; // time packet acquired, by beamnumber 

			//printf("n = %d last_millisec != millisec, interp == TRUE\n", n); n++; 
			RadarEpochMillisec += (__int64)(TimerStartCorrection); // compensate for timer board startup interval
			//printf("n = %d last_millisec != millisec, interp == TRUE\n", n); n++; 
		}
		//		if (interpolate == FALSE) { // acquire angles only
		//			printf("NO INTERPOLATION:\n"); 
		//		}
		//SystemEpochMillisec = (timebuffer.time * (__int64)1000) + (__int64)timebuffer.millitm; // take this LATER: see notes 5-10-04
		az_avg = az_sum / PMAC_acquire_times; // average last set, both angles
		//printf("n = %d last_millisec != millisec, / PMAC_acquire_times\n", n); n++; 
		el_avg = el_sum / PMAC_acquire_times; 
		//printf("n = %d last_millisec != millisec, / PMAC_acquire_times\n", n); n++; 
		//		printf( "b=%d:\nS=%I64d \nR=%I64d az = %5.2f el = %5.2f scan=%d sweep=%d volume=%d transition=%d mSec=%hu last_mSec=%hu n=%d\n", pkt->data.info.channel, SystemEpochMillisec, RadarEpochMillisec, az, el, scan_type, sweep, volume, transition, timebuffer.millitm, last_millisec, PMAC_acquire_times); 
		//		printf( "BEGIN interval:\n"); // new interval; subsequent data applies to it. 
		//		printf( "b=%d:\nS=%I64d \nR=%I64d mSec=%hu last_mSec=%hu d_mSec=%d az=%4.2f az_avg=%4.3f el=%4.2f el_avg=%4.3f n=%d\n\n", pkt->data.info.channel, SystemEpochMillisec, RadarEpochMillisec, timebuffer.millitm, last_millisec, delta_millisec, az, az_avg, el, el_avg, PMAC_acquire_times); 
		if (interpolate == TRUE) {
			//			printf( "b=%d:\nS=%I64d mSec=%hu last_mSec=%hu d_mSec=%d az_avg=%4.3f el_avg=%4.3f n=%d idx=%d\nR=%I64d\n", pkt->data.info.channel, SystemEpochMillisec, timebuffer.millitm, last_millisec, delta_millisec, az_avg, el_avg, PMAC_acquire_times, PMACDPRAMDataidx, RadarEpochMillisec); 
			//			printf( "b=%d:\nS=%I64d mSec=%hu last_mSec=%hu d_mSec=%d az_avg=%4.3f el_avg=%4.3f n=%d idx=%d\nR=%I64d BN=%I64d\n", pkt->data.info.channel, SystemEpochMillisec, timebuffer.millitm, last_millisec, delta_millisec, az_avg, el_avg, PMAC_acquire_times, PMACDPRAMDataidx, RadarEpochMillisec, pkt->data.info.beam_num); 
		} 
		else { 
			//			printf( "S=%I64d mSec=%hu last_mSec=%hu d_mSec=%d az_avg=%4.3f el_avg=%4.3f n=%d idx=%d\nR=%I64d\n", SystemEpochMillisec, timebuffer.millitm, last_millisec, delta_millisec, az_avg, el_avg, PMAC_acquire_times, PMACDPRAMDataidx, RadarEpochMillisec); 
			//			printf( "S=%I64d mSec=%hu last_mSec=%hu d_mSec=%d az_avg=%4.3f el_avg=%4.3f n=%d idx=%d\nR=%I64d BN=%I64d\n", SystemEpochMillisec, timebuffer.millitm, last_millisec, delta_millisec, az_avg, el_avg, PMAC_acquire_times, PMACDPRAMDataidx, RadarEpochMillisec, pkt->data.info.beam_num); 
		} 
		// in any case take another PMAC timeseries point: 
		PMACDPRAMData[PMACDPRAMDataidx].acquire_time = SystemEpochMillisec; // save PREVIOUS value; see notes 5-10-04 
		PMACDPRAMData[PMACDPRAMDataidx].az_avg = az_avg; 
		PMACDPRAMData[PMACDPRAMDataidx].el_avg = el_avg; 
		PMACDPRAMData[PMACDPRAMDataidx].scan_type = scan_type; 
		PMACDPRAMData[PMACDPRAMDataidx].sweep = sweep; // scan_num
		PMACDPRAMData[PMACDPRAMDataidx].volume = volume; // vol_num
		PMACDPRAMData[PMACDPRAMDataidx].whatsit = size; 
		PMACDPRAMData[PMACDPRAMDataidx].transition = transition; 
		PMACDPRAMData[PMACDPRAMDataidx].points = PMAC_acquire_times; 
		if (RadarEpochMillisec < (BeginEpochMillisec + INTERP_START_LATENCY)) {	// just started running: not enough data accumulated for interpolation
			PMACDPRAMData[PMACDPRAMDataidx].avg_az_sweep_rate = LATENCY_SWEEP_RATE; // fill w/small but finite value
			PMACDPRAMData[PMACDPRAMDataidx].avg_el_sweep_rate = LATENCY_SWEEP_RATE; 
		}
		else { // compute average sweep rate over previous 200mSec or so, set by #define
			SearchPMACDPRAMDataacqidx = PMACDPRAMDataidx; // start w/latest entry: inefficient, but safe
			while((SystemEpochMillisec - PMACDPRAMData[SearchPMACDPRAMDataacqidx].acquire_time) < SWEEP_AVERAGE_MSEC) { 
				// most-recent acquire - stored acquire < #define interval 
				SearchPMACDPRAMDataacqidx--; 
				if (SearchPMACDPRAMDataacqidx < 0) 
					SearchPMACDPRAMDataacqidx = PMACDPRAMDataSize - 1; 
			} 
			// back up 1 more; 1st entry > 200 mSec before
			SearchPMACDPRAMDataacqidx--; 
			if (SearchPMACDPRAMDataacqidx < 0) 
				SearchPMACDPRAMDataacqidx = PMACDPRAMDataSize - 1; 
			// compute sweep rate over this interval 
			PMACDPRAMData[PMACDPRAMDataidx].avg_az_sweep_rate = (az_avg - PMACDPRAMData[SearchPMACDPRAMDataacqidx].az_avg) / (SystemEpochMillisec - PMACDPRAMData[SearchPMACDPRAMDataacqidx].acquire_time); 
			PMACDPRAMData[PMACDPRAMDataidx].avg_el_sweep_rate = (el_avg - PMACDPRAMData[SearchPMACDPRAMDataacqidx].el_avg) / (SystemEpochMillisec - PMACDPRAMData[SearchPMACDPRAMDataacqidx].acquire_time); 
			//			printf("avg az rate = %4.3f avg el rate = %4.3f\n", PMACDPRAMData[PMACDPRAMDataidx].avg_az_sweep_rate, PMACDPRAMData[PMACDPRAMDataidx].avg_el_sweep_rate); 
			//			printf("avg begin at idx = %d\n", SearchPMACDPRAMDataacqidx); 
		} 
		// NOW maintain this index: 
		PMACDPRAMDataidx++; 
		if (PMACDPRAMDataidx == PMACDPRAMDataSize) // at end 
			PMACDPRAMDataidx = 0;
		//printf("PMACDPRAMDataidx = %d\n", PMACDPRAMDataidx); 
		// az el mSec last_mSec times
		//		printf( "%5.2f,%5.2f,%hu,%hu,n=%d\n", az, el, timebuffer.millitm, last_millisec, PMAC_acquire_times); 
		SystemEpochMillisec = (PMACtimebuffer.time * (__int64)1000) + (__int64)PMACtimebuffer.millitm; // take this NOW: see notes 5-10-04
		PMAC_acquire_times = 1; // count this one 
		az_sum = az; el_sum = el; // begin sums for averaging 
	} 
	else {
		PMAC_acquire_times++; 
		az_sum += az; el_sum += el; // continue sums for averaging 
	} 
	last_millisec = millisec; // record previous timestamp 
	//	printf("b:%d az = %4.3f el = %4.3f\n", pkt->data.info.channel, az, el); 
	last_az = az; 
	if (interpolate == FALSE) { // acquire angles only
		return(FALSE); //printf("no interpolation\n"); 
	}
	if (RadarEpochMillisec < (BeginEpochMillisec + INTERP_START_LATENCY)) {	// running < 200mSec: not enough data accumulated for interpolation
		printf("insufficient angle data\n");				// !note: reduce this interval after reliable  
		//printf( "S=%I64d mSec=%hu last_mSec=%hu d_mSec=%d az_avg=%4.3f el_avg=%4.3f n=%d idx=%d\nR=%I64d BN=%I64d\n", SystemEpochMillisec, timebuffer.millitm, last_millisec, delta_millisec, az_avg, el_avg, PMAC_acquire_times, PMACDPRAMDataidx, RadarEpochMillisec, pkt->data.info.beam_num); 
		//		SearchPMACDPRAMDataidx = PMACDPRAMDataidx; // save last rejected; begin searches there. 
		return(TRUE); // tell main to keep getting data 
	}
	int search_times = 0; 
	// search for previous data points bracketing current packet's timestamp: 
	// search for two PMACDPRAMData[] entries bracketing RadarEpochMillisec:
	FirstPMACDPRAMInterpidx = PMACDPRAMDataidx; // index w/most recent
	FirstPMACDPRAMInterpidx--;
	if (FirstPMACDPRAMInterpidx < 0)
		FirstPMACDPRAMInterpidx = PMACDPRAMDataSize - 1; 
	// put error trap here for when RadarEpochMillisec > most-recent time 
	while(1) { // break on find of required index 
		if (PMACDPRAMData[FirstPMACDPRAMInterpidx].acquire_time > RadarEpochMillisec) { // PMAC DPRAM Data time > beam time
			FirstPMACDPRAMInterpidx--;							// index previous entry  
			if (FirstPMACDPRAMInterpidx < 0)
				FirstPMACDPRAMInterpidx = PMACDPRAMDataSize - 1; 
		} 
		else { //  got index of first acquire-time < RadarEpochMillisec 
			SecondPMACDPRAMInterpidx = FirstPMACDPRAMInterpidx;	//  interpolation data point index 
			SecondPMACDPRAMInterpidx++;							// index previous entry for 1st 
			if (SecondPMACDPRAMInterpidx >= PMACDPRAMDataSize)
				SecondPMACDPRAMInterpidx = 0; 
			break; 
		}
	}
	//		goto interpolate;

interpolate: 
	if (PMACDPRAMDataidx == SecondPMACDPRAMInterpidx) { // second interpolation indexes future -- no data there -- return
		//	; // !remove for now	
		//printf( "S=%I64d mSec=%hu last_mSec=%hu d_mSec=%d az_avg=%4.3f el_avg=%4.3f n=%d idx=%d\nR=%I64d BN=%I64d\n", SystemEpochMillisec, timebuffer.millitm, last_millisec, delta_millisec, az_avg, el_avg, PMAC_acquire_times, PMACDPRAMDataidx, RadarEpochMillisec, pkt->data.info.beam_num); 
		//printf("PMACDPRAMDataidx == SecondPMACDPRAMInterpidx\n"); 
		return(FALSE); 
	} // tell main to wait a bit ... 
	//printf( "S=%I64d mSec=%hu last_mSec=%hu d_mSec=%d az_avg=%4.3f el_avg=%4.3f n=%d idx=%d\nR=%I64d BN=%I64d\n", SystemEpochMillisec, timebuffer.millitm, last_millisec, delta_millisec, az_avg, el_avg, PMAC_acquire_times, PMACDPRAMDataidx, RadarEpochMillisec, pkt->data.info.beam_num); 
	//printf("Interp success.\n"); 

	float az1, az2; 
	float az1_corr, az2_corr; 
	az1_corr = 0.0; az2_corr = 0.0; 
	az1 = PMACDPRAMData[FirstPMACDPRAMInterpidx].az_avg; az2 = PMACDPRAMData[SecondPMACDPRAMInterpidx].az_avg; 
	//	if (((az2 - az1) > 90.0) || ((az2 - az1) < -90.0)) // large angle discontinuity
	//		printf("big leap!! az2 = %4.3f az1 = %4.3f\n", az2, az1); 
	az1 += az1_corr; az2 += az2_corr; 
	//	az_interp = PMACDPRAMData[FirstPMACDPRAMInterpidx].az_avg+(RadarEpochMillisec - PMACDPRAMData[FirstPMACDPRAMInterpidx].acquire_time)*((PMACDPRAMData[SecondPMACDPRAMInterpidx].az_avg-PMACDPRAMData[FirstPMACDPRAMInterpidx].az_avg)/(PMACDPRAMData[SecondPMACDPRAMInterpidx].acquire_time-PMACDPRAMData[FirstPMACDPRAMInterpidx].acquire_time));
	az_interp = az1+(RadarEpochMillisec - PMACDPRAMData[FirstPMACDPRAMInterpidx].acquire_time)*((az2-az1)/(PMACDPRAMData[SecondPMACDPRAMInterpidx].acquire_time-PMACDPRAMData[FirstPMACDPRAMInterpidx].acquire_time));
	el_interp = PMACDPRAMData[FirstPMACDPRAMInterpidx].el_avg+(RadarEpochMillisec - PMACDPRAMData[FirstPMACDPRAMInterpidx].acquire_time)*((PMACDPRAMData[SecondPMACDPRAMInterpidx].el_avg-PMACDPRAMData[FirstPMACDPRAMInterpidx].el_avg)/(PMACDPRAMData[SecondPMACDPRAMInterpidx].acquire_time-PMACDPRAMData[FirstPMACDPRAMInterpidx].acquire_time));
	pkt->data.info.az = az_interp; 
	pkt->data.info.el = el_interp; 
	pkt->data.info.scan_type = PMACDPRAMData[FirstPMACDPRAMInterpidx].scan_type;
	pkt->data.info.scan_num = PMACDPRAMData[FirstPMACDPRAMInterpidx].sweep; // scan_num
	pkt->data.info.vol_num = PMACDPRAMData[FirstPMACDPRAMInterpidx].volume;
	pkt->data.info.transition = PMACDPRAMData[FirstPMACDPRAMInterpidx].transition;
	daI = az_interp - last_ai; deI = el_interp - last_ei;
	//printf("%d\n", pkt->data.info.channel);
	//azI, elI interpolated angles put in packet: 
	//	fprintf(db_fp, "REMSec = %I64d: azI = %4.3f daI = %4.3f elI = %4.3f deI = %4.3f\n", RadarEpochMillisec, az_interp, daI, el_interp, deI); 
	//printf("REMSec = %I64d\ntN+1   = %I64d \ntN     = %I64d idxN+1 = %d idxN = %d idxCur = %d aN+1 = %4.3f aN = %4.3f\n\n", RadarEpochMillisec, PMACDPRAMData[SecondPMACDPRAMInterpidx].acquire_time, PMACDPRAMData[FirstPMACDPRAMInterpidx].acquire_time, SecondPMACDPRAMInterpidx, FirstPMACDPRAMInterpidx, PMACDPRAMDataidx, PMACDPRAMData[SecondPMACDPRAMInterpidx].az_avg, PMACDPRAMData[FirstPMACDPRAMInterpidx].az_avg); 
	last_ai = az_interp; last_ei = el_interp; 
	_ftime( &PMACtimebuffer ); millisec = PMACtimebuffer.millitm; 
	//printf("PMACDPRAMData: sweep=%d volume=%d\n", PMACDPRAMData[FirstPMACDPRAMInterpidx].sweep, PMACDPRAMData[FirstPMACDPRAMInterpidx].volume); 
	return(TRUE);
}

