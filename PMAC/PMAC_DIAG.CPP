////////////////////////////////////////////////////////////////
// File - pmac_diag.c
//
// This is a diagnostics application for accessing the PMAC card.
// Code was generated by DriverWizard v6.02 - http://www.jungo.com.
// The library accesses the hardware via WinDriver functions.
// It accesses the hardware via WinDriver functions.
// 
// Copyright (c) 2003 Jungo Ltd.  http://www.jungo.com
// 
////////////////////////////////////////////////////////////////

#include "pmac_lib.h"
#include "c:/windriver6/samples/shared/pci_diag_lib.h"
#include <stdio.h>
#include "c:/windriver6/include/status_strings.h"

// input command from user
static char line[256];

char *PMAC_GetAddrSpaceName(PMAC_ADDR addrSpace)
{
    return 
        addrSpace==PMAC_AD_BAR0 ? "Addr Space BAR0" :
        addrSpace==PMAC_AD_BAR1 ? "Addr Space BAR1" :
        addrSpace==PMAC_AD_BAR2 ? "Addr Space BAR2" :
        addrSpace==PMAC_AD_BAR3 ? "Addr Space BAR3" :
        addrSpace==PMAC_AD_BAR4 ? "Addr Space BAR4" :
        addrSpace==PMAC_AD_BAR5 ? "Addr Space BAR5" :
        addrSpace==PMAC_AD_EPROM ? "EEPROM Addr Space" :
        "Invalid";
}

void PMAC_AccessRanges(PMAC_HANDLE hPMAC)
{
    int cmd, cmd2, i;
    UINT addr, data = 0;
    PMAC_ADDR ad_sp = 0;
    PMAC_MODE ad_mode = PMAC_MODE_DWORD;

    for (; ad_sp<PMAC_ITEMS && !PMAC_IsAddrSpaceActive(hPMAC, ad_sp); ad_sp++)
    if (ad_sp==PMAC_ITEMS)
    {
        printf ("No active memory or IO ranges on board!\n");
        return;
    }

    do
    {
        printf ("Access the board's memory and IO ranges\n");
        printf ("---------------------------------------\n");
        printf ("1. Change active memory/IO space: %s\n",PMAC_GetAddrSpaceName(ad_sp));
        printf ("2. Toggle active mode: %s\n", 
            ad_mode==PMAC_MODE_BYTE ? "BYTE (8 bit)" :
            ad_mode==PMAC_MODE_WORD ? "WORD (16 bit)" : "DWORD (32 bit)");
        printf ("3. Read from board\n");
        printf ("4. Write to board\n");
        printf ("99. Back to main menu\n");
        printf ("\n");
        printf ("Enter option: ");
        cmd = 0;
        fgets(line, sizeof(line), stdin);
        sscanf (line, "%d",&cmd);
        switch (cmd)
        {
        case 1:
            printf ("Choose memory or IO space:\n");
            printf ("--------------------------\n");
            for (i=0; i<PMAC_ITEMS; i++)
            {
                printf ("%d. %s", i+1, PMAC_GetAddrSpaceName(i));
                if (!PMAC_IsAddrSpaceActive(hPMAC, (PMAC_ADDR) i))
                    printf (" - space not active");
                printf ("\n");
            }
            printf ("Enter option: ");
            cmd2 = 99;
            fgets(line, sizeof(line), stdin);
            sscanf (line, "%d",&cmd2);
            if (cmd2>=1 && cmd2<PMAC_ITEMS+1)
            {
                ad_sp = cmd2-1;
                if (!PMAC_IsAddrSpaceActive(hPMAC, ad_sp))
                    printf ("Chosen space not active!\n");
            }
            break;
        case 2:
            ad_mode = (ad_mode + 1) % 3;
            break;
        case 3:
            printf ("Enter offset to read from: ");
            fgets(line, sizeof(line), stdin);
            sscanf (line, "%x", &addr);
            switch (ad_mode)
            {
            case PMAC_MODE_BYTE:
                data = PMAC_ReadByte(hPMAC, ad_sp, addr);
                break;
            case PMAC_MODE_WORD:
                data = PMAC_ReadWord(hPMAC, ad_sp, addr);
                break;
            case PMAC_MODE_DWORD:
                data = PMAC_ReadDword(hPMAC, ad_sp, addr);
                break;
            }
            printf ("Value read: %x\n", data);
            break;
        case 4:
            printf ("Enter offset to write to: ");
            fgets(line, sizeof(line), stdin);
            sscanf (line,"%x", &addr);
            printf ("Enter data to write %s: ",
                ad_mode==PMAC_MODE_BYTE ? "BYTE (8 bit)" :
                ad_mode==PMAC_MODE_WORD ? "WORD (16 bit)" : "DWORD (32 bit)");
            fgets(line, sizeof(line), stdin);
            sscanf (line, "%x",&data);
            switch (ad_mode)
            {
            case PMAC_MODE_BYTE:
                PMAC_WriteByte(hPMAC, ad_sp, addr, (BYTE) data);
                break;
            case PMAC_MODE_WORD:
                PMAC_WriteWord(hPMAC, ad_sp, addr, (WORD) data);
                break;
            case PMAC_MODE_DWORD:
                PMAC_WriteDword(hPMAC, ad_sp, addr, data);
                break;
            }
            break;
        }
    } while (cmd!=99);
}

void PMAC_IntHandlerRoutine(PMAC_HANDLE hPMAC, PMAC_INT_RESULT *intResult)
{
    printf ("Got Int number %u\n", (UINT)intResult->dwCounter);
}

void PMAC_EnableDisableInterrupts(PMAC_HANDLE hPMAC)
{
    int cmd;

    printf ("WARNING!!!\n");
    printf ("----------\n");
    printf ("Your hardware has level sensitive interrupts.\n");
    printf ("You must modify the source code of PMAC_IntEnable(), in the file pmac_lib.c,\n");
    printf ("to acknowledge the interrupt before enabling interrupts.\n");
    printf ("Without this modification, your PC will HANG upon interrupt!\n");
    printf ("\n");

    do
    {
        printf ("Enable / Disable interrupts\n");
        printf ("---------------------------\n");
        printf ("1. %s Int\n", PMAC_IntIsEnabled(hPMAC) ? "Disable" : "Enable");
        printf ("99. Back to main menu\n");
        printf ("\n");
        printf ("Enter option: ");
        cmd = 0;
        fgets(line, sizeof(line), stdin);
        sscanf (line, "%d",&cmd);
        switch (cmd)
        {
        case 1:
            if (PMAC_IntIsEnabled(hPMAC))
            {
                printf ("Disabling interrupt Int\n");
                PMAC_IntDisable(hPMAC);
            }
            else
            {
                printf ("Enabling interrupt Int\n");
                if (!PMAC_IntEnable(hPMAC, PMAC_IntHandlerRoutine))
                    printf ("%s", PMAC_ErrorString);
            }
            break;
        }
    } while (cmd!=99);
}

void PMAC_HandlerFunc(WD_EVENT *event, void *data)
{
    printf("\nreceive notification: ");
    switch (event->dwAction)
    {
    case WD_INSERT:
        printf("WD_INSERT\n");
        break;
    case WD_REMOVE:
        printf("WD_REMOVE\n");
        break;
    case WD_POWER_CHANGED_D0:
        printf("WD_POWER_CHANGED_D0\n");
        break;
    case WD_POWER_CHANGED_D1:
        printf("WD_POWER_CHANGED_D1\n");
        break;
    case WD_POWER_CHANGED_D2:
        printf("WD_POWER_CHANGED_D2\n");
        break;
    case WD_POWER_CHANGED_D3:
        printf("WD_POWER_CHANGED_D3\n");
        break;
    case WD_POWER_SYSTEM_WORKING:
        printf("WD_POWER_SYSTEM_WORKING\n");
        break;
    case WD_POWER_SYSTEM_SLEEPING1:
        printf("WD_POWER_SYSTEM_SLEEPING1\n");
        break;
    case WD_POWER_SYSTEM_SLEEPING2:
        printf("WD_POWER_SYSTEM_SLEEPING2\n");
        break;
    case WD_POWER_SYSTEM_SLEEPING3:
        printf("WD_POWER_SYSTEM_SLEEPING3\n");
        break;
    case WD_POWER_SYSTEM_HIBERNATE:
        printf("WD_POWER_SYSTEM_HIBERNATE\n");
        break;
    case WD_POWER_SYSTEM_SHUTDOWN:
        printf("WD_POWER_SYSTEM_SHUTDOWN\n");
        break;
    }
}

PMAC_HANDLE PMAC_LocateAndOpenBoard(DWORD dwVendorID, DWORD dwDeviceID)
{
    DWORD cards, my_card;
    PMAC_HANDLE hPMAC = NULL;

    if (dwVendorID==0)
    {
        printf ("Enter VendorID: ");
        fgets(line, sizeof(line), stdin);
        sscanf (line, "%x",&dwVendorID);
        if (dwVendorID==0) return NULL;

        printf ("Enter DeviceID: ");
        fgets(line, sizeof(line), stdin);
        sscanf (line, "%x",&dwDeviceID);
    }
    cards = PMAC_CountCards (dwVendorID, dwDeviceID);
    if (cards==0)
    {
        printf ("%s", PMAC_ErrorString);
        return NULL;
    }
    else if (cards==1)
        my_card = 1;
    else
    {
        UINT i;

        printf ("Found %u matching PCI cards\n", (UINT)cards);
        printf ("Select card (1-%u): ", (UINT)cards);
        i = 0;
        fgets(line, sizeof(line), stdin);
        sscanf (line, "%d",&i);
        if (i>=1 && i <=cards) my_card = i;
        else 
        {
            printf ("Choice is out of range\n");
            return NULL;
        }
    }
    if (!PMAC_Open (&hPMAC, dwVendorID, dwDeviceID, my_card - 1))
    {
        printf ("%s", PMAC_ErrorString);
        return NULL;
    }
    printf ("PMAC PCI card found!\n");
    return hPMAC;
}

int main(int argc, char *argv[])
{
    int cmd;
    PMAC_HANDLE hPMAC = NULL;
    HANDLE hWD;
    WD_PCI_SLOT pciSlot;
    DWORD dwAction = 0;
    BOOL fRegisteredEvent = FALSE;

    printf ("PMAC diagnostic utility.\n");
    printf ("Application accesses hardware using WinDriver.\n");

    // Make sure WinDriver is loaded
    if (!PCI_Get_WD_handle(&hWD))
        return 0;
    WD_Close (hWD);

    hPMAC = PMAC_LocateAndOpenBoard(PMAC_DEFAULT_VENDOR_ID, PMAC_DEFAULT_DEVICE_ID);

    do
    {
        printf ("\n");
        printf ("PMAC main menu\n");
        printf ("-------------------\n");
        printf ("1. Scan PCI bus\n");
        printf ("2. Locate/Choose PMAC board\n");
        if (hPMAC)
        {
            printf ("3. PCI configuration registers\n");
            printf ("5. Access PMAC memory and IO ranges\n");
            printf ("6. Enable / Disable interrupts\n");
            printf ("7. %s events\n", fRegisteredEvent ? "Unregister" : "Register");
        }
        printf ("99. Exit\n");
        printf ("Enter option: ");
        cmd = 0;
        fgets(line, sizeof(line), stdin);
        sscanf (line, "%d",&cmd);
        switch (cmd)
        {
        case 1: // Scan PCI bus
            PCI_Print_all_cards_info();
            break;
        case 2: // Locate PMAC board
            if (hPMAC) PMAC_Close(hPMAC);
            hPMAC = PMAC_LocateAndOpenBoard(0, 0);
            if (!hPMAC)
                printf("PMAC card open failed!\n");
            break;
        case 3: // PCI configuration registers
            if (hPMAC)
            {
                WD_PCI_SLOT pciSlot;
                PMAC_GetPciSlot(hPMAC, &pciSlot);
                PCI_EditConfigReg(pciSlot);
                break;
            }
        case 5: // Access PMAC memory and IO ranges
            if (hPMAC) PMAC_AccessRanges(hPMAC);
            break;
        case 6: // Enable / Disable interrupts
            if (hPMAC)
                PMAC_EnableDisableInterrupts(hPMAC);
            break;
        case 7: // Register / Unregister event
            if (hPMAC && !fRegisteredEvent)
            {
                dwAction |= WD_INSERT | WD_REMOVE;
                dwAction |= WD_ACTIONS_POWER;

                PMAC_GetPciSlot(hPMAC, &pciSlot);

                if (!PMAC_RegisterEvent(hPMAC, dwAction, PMAC_DEFAULT_VENDOR_ID,
                    PMAC_DEFAULT_DEVICE_ID, pciSlot, PMAC_HandlerFunc))
                    printf ("%s", PMAC_ErrorString);
                else
                    fRegisteredEvent = TRUE;
                break;
            }
            if (hPMAC && fRegisteredEvent)
            {
                fRegisteredEvent = FALSE;
                PMAC_UnregisterEvent(hPMAC);
            }
            break;
        }
    } while (cmd!=99);

    if (hPMAC)
        PMAC_Close(hPMAC);

    return 0;
}

