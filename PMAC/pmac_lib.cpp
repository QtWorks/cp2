//////////////////////////////////////////////////////////////////////
// File - pmac_lib.c
//
// Library for accessing the PMAC card.
// Code was generated by DriverWizard v6.02 - http://www.jungo.com.
// The library accesses the hardware via WinDriver functions.
// 
// Copyright (c) 2003 Jungo Ltd.  http://www.jungo.com
// 
//////////////////////////////////////////////////////////////////////

#include	<stdafx.h>  
#include "../CP2Exec/stdafx.h"

#include "pmac_lib.h"
#include "c:/windriver6/include/windrvr_int_thread.h"
#include "c:/windriver6/include/windrvr_events.h"
#include "c:/windriver6/include/status_strings.h"
#ifndef __KERNEL__
	#include <stdio.h>
#endif

// If an error occurs, this string will be set to contain a relevant error message
CHAR PMAC_ErrorString[1024];

// internal data structures
typedef struct
{
    WD_INTERRUPT Int;
    HANDLE hThread;
    PMAC_INT_HANDLER funcIntHandler;
} PMAC_INT_INTERRUPT;

typedef struct
{
    DWORD index;
    BOOL  fIsMemory;
    BOOL  fActive;
} PMAC_ADDR_DESC;

typedef struct PMAC_STRUCT
{
    HANDLE hWD;
    HANDLE hEvent;
    PMAC_INT_INTERRUPT Int;
    WD_PCI_SLOT pciSlot;
    PMAC_ADDR_DESC addrDesc[PMAC_ITEMS];
    WD_CARD_REGISTER cardReg;
} PMAC_STRUCT;

// internal function used by PMAC_Open()
BOOL PMAC_DetectCardElements(PMAC_HANDLE hPMAC);

// Function: PMAC_CountCards()
//   Count the number of PCI cards that meets the given criteria.
// Parameters:
//   hPMAC [in] handle to the card as received from PMAC_Open().
//   dwVendorID [in] indicates the vendor ID of the PCI card to search.
//     0 indicates all vendor IDs.
//   dwDeviceID [in] indicates the Device ID of the PCI card to search.
//     0 indicates all device IDs.
// Return Value:
//   the number of PCI cards found.
DWORD PMAC_CountCards (DWORD dwVendorID, DWORD dwDeviceID)
{
    WD_VERSION ver;
    WD_PCI_SCAN_CARDS pciScan;
    HANDLE hWD = INVALID_HANDLE_VALUE;
    DWORD dwStatus;

    PMAC_RegisterWinDriver();

    PMAC_ErrorString[0] = '\0';
    hWD = WD_Open();

    // Verify that the handle is valid and that the version number is correct
    if (hWD==INVALID_HANDLE_VALUE) 
    {
        sprintf(PMAC_ErrorString, "Failed opening WinDriver device\n");
        return 0;
    }

    BZERO(ver);
    WD_Version(hWD,&ver);
    if (ver.dwVer<WD_VER) 
    {
        sprintf(PMAC_ErrorString, "Incorrect WinDriver version. Expected %d.%02d, got %d.%02d\n",
             WD_VER/100, WD_VER, ver.dwVer/100, ver.dwVer);
        WD_Close(hWD);
        return 0;
    }

    BZERO(pciScan);
    pciScan.searchId.dwVendorId = dwVendorID;
    pciScan.searchId.dwDeviceId = dwDeviceID;
    dwStatus = WD_PciScanCards (hWD, &pciScan);
    WD_Close (hWD);
    if (dwStatus)
    {
        sprintf(PMAC_ErrorString, "WD_PciScanCards() failed with status 0x%x - %s\n",
            dwStatus, Stat2Str(dwStatus));
    }
    else if (pciScan.dwCards==0)
        sprintf(PMAC_ErrorString, "no cards found\n");
    return pciScan.dwCards;
}

// Function: PMAC_Open()
//   Register a PCI card that meets the given criteria to enable working with it.
//   The handle returned from this function is used by most of the functions in this file.
// Parameters:
//   phPMAC [out] returns the handle to the opened card.
//   dwVendorID [in] indicates the vendor ID of the PCI card to open.
//     0 indicates all vendor IDs.
//   dwDeviceID [in] indicates the device ID of the PCI card to open.
//     0 indicates all device IDs.
//   nCardNum [in] indicates the index number of the PCI card that meets
//     the criteria of the given vendor and device ID.
// Return Value:
//   TRUE if the card was opened successfully. FALSE if there were any errors.
BOOL PMAC_Open (PMAC_HANDLE *phPMAC, DWORD dwVendorID, DWORD dwDeviceID, DWORD nCardNum)
{
    PMAC_HANDLE hPMAC = (PMAC_HANDLE)malloc(sizeof(PMAC_STRUCT));

    WD_VERSION ver;
    DWORD dwStatus;
    WD_PCI_SCAN_CARDS pciScan;
    WD_PCI_CARD_INFO pciCardInfo;

    *phPMAC = NULL;
    PMAC_ErrorString[0] = '\0';
    if (!hPMAC)
    {
        sprintf(PMAC_ErrorString, "Failed allocating memory\n");
        return FALSE;
    }
    BZERO(*hPMAC);

    PMAC_RegisterWinDriver();

    hPMAC->hWD = WD_Open();

    // Verify that the handle is valid and that the version number is correct
    if (hPMAC->hWD==INVALID_HANDLE_VALUE)
    {
        sprintf(PMAC_ErrorString, "Failed opening WinDriver device\n");
        goto Exit;
    }

    BZERO(ver);
    WD_Version(hPMAC->hWD,&ver);
    if (ver.dwVer<WD_VER)
    {
        sprintf(PMAC_ErrorString, "Incorrect WinDriver version. Expected %d.%02d, got %d.%02d\n",
             WD_VER/100, WD_VER, ver.dwVer/100, ver.dwVer);
        goto Exit;
    }

    BZERO(pciScan);
    pciScan.searchId.dwVendorId = dwVendorID;
    pciScan.searchId.dwDeviceId = dwDeviceID;
    dwStatus = WD_PciScanCards(hPMAC->hWD, &pciScan);
    if (dwStatus)
    {
        sprintf(PMAC_ErrorString, "WD_PciScanCards() failed with status 0x%x - %s\n",
            dwStatus, Stat2Str(dwStatus));
        goto Exit;
    }
    if (pciScan.dwCards==0)
    {
        sprintf(PMAC_ErrorString, "Could not find PCI card\n");
        goto Exit;
    }
    if (pciScan.dwCards<=nCardNum)
    {
        sprintf(PMAC_ErrorString, "Card is out of range of available cards\n");
        goto Exit;
    }
    // Found at least one card
    BZERO(pciCardInfo);
    pciCardInfo.pciSlot = pciScan.cardSlot[nCardNum];
    dwStatus = WD_PciGetCardInfo(hPMAC->hWD, &pciCardInfo);
    if (dwStatus)
    {
        sprintf(PMAC_ErrorString, "WD_PciGetCardInfo() failed with status 0x%x - %s\n",
            dwStatus, Stat2Str(dwStatus));
        goto Exit;
    }
    hPMAC->pciSlot = pciCardInfo.pciSlot;
    hPMAC->cardReg.Card = pciCardInfo.Card;

    hPMAC->cardReg.fCheckLockOnly = FALSE;
    dwStatus = WD_CardRegister(hPMAC->hWD, &hPMAC->cardReg);
    if (dwStatus)
    {
        sprintf(PMAC_ErrorString, "Failed locking device. Status 0x%x - %s\n",
            dwStatus, Stat2Str(dwStatus));
        goto Exit;
    }

    if (!PMAC_DetectCardElements(hPMAC))
    {
        sprintf (PMAC_ErrorString, "Card does not have all items expected for PMAC\n");
        goto Exit;
    }

    // PMAC_Open() was successful
    *phPMAC = hPMAC;
    return TRUE;

Exit:
printf("PMAC_ErrorString %s\n", PMAC_ErrorString); 
    // An error occured during the execution of PMAC_Open()
    if (hPMAC->cardReg.hCard) 
        WD_CardUnregister(hPMAC->hWD, &hPMAC->cardReg);
    if (hPMAC->hWD!=INVALID_HANDLE_VALUE)
        WD_Close(hPMAC->hWD);
    free (hPMAC);
    return FALSE;
}

// Function: PMAC_Close()
//   Unregister an opened card.
// Parameters:
//   hPMAC [in] handle to the card as received from PMAC_Open().
// Return Value:
//   None.
void PMAC_Close(PMAC_HANDLE hPMAC)
{
    // disable interrupts
    if (PMAC_IntIsEnabled(hPMAC))
        PMAC_IntDisable(hPMAC);

    // unregister card
    if (hPMAC->cardReg.hCard) 
        WD_CardUnregister(hPMAC->hWD, &hPMAC->cardReg);

    // close WinDriver
    WD_Close(hPMAC->hWD);

    free (hPMAC);
}

// Function: PMAC_RegisterWinDriver()
//   Enter a license string into WinDriver module.
// Parameters:
//   None.
// Return Value:
//   None.
void PMAC_RegisterWinDriver()
{
    HANDLE hWD;
    WD_LICENSE lic;

    hWD = WD_Open();
    if (hWD!=INVALID_HANDLE_VALUE)
    {
//!         strcpy(lic.cLicense, "6c3cda80693a5b3a73de254669e59be727ce2f79.Binet"); // comm'l license
strcpy(lic.cLicense, "6c3cda80693a5b3a738e9f330873b005dfb26f5d.Binet"); // academic license
         WD_License(hWD, &lic);
         WD_Close(hWD);
		printf("WD_Open() returned hWD = 0x%x\n", hWD);
    }
	else
		printf("WD_Open() returned INVALID_HANDLE_VALUE\n");
}

// Function: PMAC_WritePCIReg()
//   Write a DWORD to the PCI configuration space.
// Parameters:
//   hPMAC [in] handle to the card as received from PMAC_Open().
//   dwReg [in] offset of the register in the PCI configuration space.
//     dwData [in] the value to write into the register.
// Return Value:
//   None.
void PMAC_WritePCIReg(PMAC_HANDLE hPMAC, DWORD dwReg, DWORD dwData)
{
    WD_PCI_CONFIG_DUMP pciCnf;

    BZERO(pciCnf);
    pciCnf.pciSlot = hPMAC->pciSlot;
    pciCnf.pBuffer = &dwData;
    pciCnf.dwOffset = dwReg;
    pciCnf.dwBytes = 4;
    pciCnf.fIsRead = FALSE;
    WD_PciConfigDump(hPMAC->hWD,&pciCnf);
}

// Function: PMAC_ReadPCIReg()
//   Read a DWORD from the PCI configuration space.
// Parameters:
//   hPMAC [in] handle to the card as received from PMAC_Open().
//   dwReg [in] offset of the register in the PCI configuration space.
// Return Value:
//   the value of the register.
DWORD PMAC_ReadPCIReg(PMAC_HANDLE hPMAC, DWORD dwReg)
{
    WD_PCI_CONFIG_DUMP pciCnf;
    DWORD dwVal;

    BZERO(pciCnf);
    pciCnf.pciSlot = hPMAC->pciSlot;
    pciCnf.pBuffer = &dwVal;
    pciCnf.dwOffset = dwReg;
    pciCnf.dwBytes = 4;
    pciCnf.fIsRead = TRUE;
    WD_PciConfigDump(hPMAC->hWD,&pciCnf);
    return dwVal;
}

BOOL PMAC_DetectCardElements(PMAC_HANDLE hPMAC)
{
    DWORD i;
    DWORD ad_sp;

    BZERO(hPMAC->Int);
    BZERO(hPMAC->addrDesc);

    for (i=0; i<hPMAC->cardReg.Card.dwItems; i++)
    {
        WD_ITEMS *pItem = &hPMAC->cardReg.Card.Item[i];

        switch (pItem->item)
        {
        case ITEM_MEMORY:
            ad_sp = pItem->I.Mem.dwBar;
            hPMAC->addrDesc[ad_sp].fIsMemory = TRUE;
            hPMAC->addrDesc[ad_sp].fActive = TRUE;
            hPMAC->addrDesc[ad_sp].index = i;
            break;
        case ITEM_IO:
            ad_sp = pItem->I.IO.dwBar;
            hPMAC->addrDesc[ad_sp].fIsMemory = FALSE;
            hPMAC->addrDesc[ad_sp].fActive = TRUE;
            hPMAC->addrDesc[ad_sp].index = i;
            break;
        case ITEM_INTERRUPT:
            if (hPMAC->Int.Int.hInterrupt) return FALSE;
            hPMAC->Int.Int.hInterrupt = pItem->I.Int.hInterrupt;
            break;
        }
    }

    // Verify that all the necessary items were found
    // Verify that an interrupt was found
    if (!hPMAC->Int.Int.hInterrupt) 
        return FALSE;

    // Verify that at least one memory/IO space was found
    for (i = 0; i<PMAC_ITEMS; i++)
        if (PMAC_IsAddrSpaceActive(hPMAC, (PMAC_ADDR) i)) break;
    if (i==PMAC_ITEMS) return FALSE;

    return TRUE;
}

// Function: PMAC_IsAddrSpaceActive()
//   Check if the given address space is configured and active.
// Parameters:
//   hPMAC [in] handle to the card as received from PMAC_Open().
//   addrSpace [in] the address space to check.
// Return Value:
//   TRUE if the address space is active. FALSE otherwise.
BOOL PMAC_IsAddrSpaceActive(PMAC_HANDLE hPMAC, PMAC_ADDR addrSpace)
{
    return hPMAC->addrDesc[addrSpace].fActive;
}

// Function: PMAC_GetPciSlot()
//   Return the logical location (bus, slot and function) of the PCI card.
// Parameters:
//   hPMAC [in] handle to the card as received from PMAC_Open().
//   pPciSlot [out] - pointer to a caller allocated space that will hold the
//     logical location of the card
// Return Value:
//   None.
void PMAC_GetPciSlot(PMAC_HANDLE hPMAC, WD_PCI_SLOT *pPciSlot)
{
    memcpy((PVOID)pPciSlot, &(hPMAC->pciSlot), sizeof(WD_PCI_SLOT));
}

// General read/write functions

// Function: PMAC_ReadWriteBlock()
//   Read/Write data from/to the card's memory/IO into/from a given buffer.
// Parameters:
//   hPMAC [in] handle to the card as received from PMAC_Open().
//   addrSpace [in] the address space of the card to access.
//   dwOffset [in] offset relative to the beginning of the address space to access.
//   fRead [in] direction of operation:
//     TRUE indicates read from the card's memory/IO into the given buffer.
//     FALSE indicates write from the given buffer to the card's memory/IO.
//   buf [in/out] a caller allocated buffer to read/write to/from.
//   dwBytes [in] the number of bytes to read/write. The allocated buffer should be at least dwBytes long.
//   mode [in] perform the data transfer byte by byte / word by word / dword by dword.
// Return Value:
//   None.
void PMAC_ReadWriteBlock(PMAC_HANDLE hPMAC, PMAC_ADDR addrSpace,
    DWORD dwOffset, BOOL fRead, PVOID buf, DWORD dwBytes, PMAC_MODE mode)
{
    WD_TRANSFER trans;
    BOOL fMem = hPMAC->addrDesc[addrSpace].fIsMemory;
    // safety check: is the address range active
    if (!PMAC_IsAddrSpaceActive(hPMAC, addrSpace)) return;
    BZERO(trans);
    if (fRead)
    {
        if (mode==PMAC_MODE_BYTE) trans.cmdTrans = fMem ? RM_SBYTE : RP_SBYTE;
        else if (mode==PMAC_MODE_WORD) trans.cmdTrans = fMem ? RM_SWORD : RP_SWORD;
        else if (mode==PMAC_MODE_DWORD) trans.cmdTrans = fMem ? RM_SDWORD : RP_SDWORD;
    }
    else
    {
        if (mode==PMAC_MODE_BYTE) trans.cmdTrans = fMem ? WM_SBYTE : WP_SBYTE;
        else if (mode==PMAC_MODE_WORD) trans.cmdTrans = fMem ? WM_SWORD : WP_SWORD;
        else if (mode==PMAC_MODE_DWORD) trans.cmdTrans = fMem ? WM_SDWORD : WP_SDWORD;
    }
    if (fMem)
        trans.dwPort = hPMAC->cardReg.Card.Item[hPMAC->addrDesc[addrSpace].index].I.Mem.dwTransAddr;
    else trans.dwPort = hPMAC->cardReg.Card.Item[hPMAC->addrDesc[addrSpace].index].I.IO.dwAddr;
    trans.dwPort += dwOffset;

    trans.fAutoinc = TRUE;
    trans.dwBytes = dwBytes;
    trans.dwOptions = 0;
    trans.Data.pBuffer = buf;
    WD_Transfer (hPMAC->hWD, &trans);
}

// Function: PMAC_ReadByte()
//   Read a Byte from the card's memory/IO.
// Parameters:
//   hPMAC [in] handle to the card as received from PMAC_Open().
//   addrSpace [in] the address space of the card to access.
//   dwOffset [in] offset relative to the beginning of the address space to access.
// Return Value:
//   The value read from the card's memory/IO.
BYTE PMAC_ReadByte (PMAC_HANDLE hPMAC, PMAC_ADDR addrSpace, DWORD dwOffset)
{
    BYTE data;
    if (hPMAC->addrDesc[addrSpace].fIsMemory)
    {
        PBYTE pData = (PBYTE) (hPMAC->cardReg.Card.Item[hPMAC->addrDesc[addrSpace].index].I.Mem.dwUserDirectAddr + dwOffset);
        data = *pData; // read directly from the memory mapped range
    }
    else PMAC_ReadWriteBlock(hPMAC, addrSpace, dwOffset, TRUE, &data, sizeof(BYTE), PMAC_MODE_BYTE);
    return data;
}

// Function: PMAC_ReadWord()
//   Read a Word from the card's memory/IO.
// Parameters:
//   hPMAC [in] handle to the card as received from PMAC_Open().
//   addrSpace [in] the address space of the card to access.
//   dwOffset [in] offset relative to the beginning of the address space to access.
// Return Value:
//   The value read from the card's memory/IO.
WORD PMAC_ReadWord (PMAC_HANDLE hPMAC, PMAC_ADDR addrSpace, DWORD dwOffset)
{
    WORD data;
    if (hPMAC->addrDesc[addrSpace].fIsMemory)
    {
        PWORD pData = (PWORD) (hPMAC->cardReg.Card.Item[hPMAC->addrDesc[addrSpace].index].I.Mem.dwUserDirectAddr + dwOffset);
        data = *pData; // read directly from the memory mapped range
    }
    else PMAC_ReadWriteBlock(hPMAC, addrSpace, dwOffset, TRUE, &data, sizeof(WORD), PMAC_MODE_WORD);
    return data;
}

// Function: PMAC_ReadDword()
//   Read a Dword from the card's memory/IO.
// Parameters:
//   hPMAC [in] handle to the card as received from PMAC_Open().
//   addrSpace [in] the address space of the card to access.
//   dwOffset [in] offset relative to the beginning of the address space to access.
// Return Value:
//   The value read from the card's memory/IO.
DWORD PMAC_ReadDword (PMAC_HANDLE hPMAC, PMAC_ADDR addrSpace, DWORD dwOffset)
{
    DWORD data;
    if (hPMAC->addrDesc[addrSpace].fIsMemory)
    {
        PDWORD pData = (PDWORD) (hPMAC->cardReg.Card.Item[hPMAC->addrDesc[addrSpace].index].I.Mem.dwUserDirectAddr + dwOffset);
        data = *pData; // read directly from the memory mapped range
    }
    else PMAC_ReadWriteBlock(hPMAC, addrSpace, dwOffset, TRUE, &data, sizeof(DWORD), PMAC_MODE_DWORD);
    return data;
}

// Function: PMAC_WriteByte()
//   Write a Byte to the card's memory/IO.
// Parameters:
//   hPMAC [in] handle to the card as received from PMAC_Open().
//   addrSpace [in] the address space of the card to access.
//   dwOffset [in] offset relative to the beginning of the address space to access.
//   data [in] the data to write to the card's memory/IO.
// Return Value:
//   None.
void PMAC_WriteByte (PMAC_HANDLE hPMAC, PMAC_ADDR addrSpace, DWORD dwOffset, BYTE data)
{
    if (hPMAC->addrDesc[addrSpace].fIsMemory)
    {
        PBYTE pData = (PBYTE) (hPMAC->cardReg.Card.Item[hPMAC->addrDesc[addrSpace].index].I.Mem.dwUserDirectAddr + dwOffset);
        *pData = data; // write directly to the memory mapped range
    }
    else PMAC_ReadWriteBlock(hPMAC, addrSpace, dwOffset, FALSE, &data, sizeof(BYTE), PMAC_MODE_BYTE);
}

// Function: PMAC_WriteWord()
//   Write a Word to the card's memory/IO.
// Parameters:
//   hPMAC [in] handle to the card as received from PMAC_Open().
//   addrSpace [in] the address space of the card to access.
//   dwOffset [in] offset relative to the beginning of the address space to access.
//   data [in] the data to write to the card's memory/IO.
// Return Value:
//   None.
void PMAC_WriteWord (PMAC_HANDLE hPMAC, PMAC_ADDR addrSpace, DWORD dwOffset, WORD data)
{
    if (hPMAC->addrDesc[addrSpace].fIsMemory)
    {
        PWORD pData = (PWORD) (hPMAC->cardReg.Card.Item[hPMAC->addrDesc[addrSpace].index].I.Mem.dwUserDirectAddr + dwOffset);
        *pData = data; // write directly to the memory mapped range
    }
    else PMAC_ReadWriteBlock(hPMAC, addrSpace, dwOffset, FALSE, &data, sizeof(WORD), PMAC_MODE_WORD);
}

// Function: PMAC_WriteDword()
//   Write a Dword to the card's memory/IO.
// Parameters:
//   hPMAC [in] handle to the card as received from PMAC_Open().
//   addrSpace [in] the address space of the card to access.
//   dwOffset [in] offset relative to the beginning of the address space to access.
//   data [in] the data to write to the card's memory/IO.
// Return Value:
//   None.
void PMAC_WriteDword (PMAC_HANDLE hPMAC, PMAC_ADDR addrSpace, DWORD dwOffset, DWORD data)
{
    if (hPMAC->addrDesc[addrSpace].fIsMemory)
    {
        PDWORD pData = (PDWORD) (hPMAC->cardReg.Card.Item[hPMAC->addrDesc[addrSpace].index].I.Mem.dwUserDirectAddr + dwOffset);
        *pData = data; // write directly to the memory mapped range
    }
    else PMAC_ReadWriteBlock(hPMAC, addrSpace, dwOffset, FALSE, &data, sizeof(DWORD), PMAC_MODE_DWORD);
}

// Function: PMAC_IntIsEnabled()
//   Check if the interrupt is enabled.
// Parameters:
//   hPMAC [in] handle to the card as received from PMAC_Open().
// Return Value:
//   TRUE if the interrupt is enabled. FALSE otherwise.
BOOL PMAC_IntIsEnabled (PMAC_HANDLE hPMAC)
{
    if (!hPMAC->Int.hThread) return FALSE;
    return TRUE;
}

void PMAC_IntHandler (PVOID pData)
{
    PMAC_HANDLE hPMAC = (PMAC_HANDLE) pData;
    PMAC_INT_RESULT intResult;
    intResult.dwCounter = hPMAC->Int.Int.dwCounter;
    intResult.dwLost = hPMAC->Int.Int.dwLost;
    intResult.fStopped = hPMAC->Int.Int.fStopped;
    hPMAC->Int.funcIntHandler(hPMAC, &intResult);
}

// Function: PMAC_IntEnable()
//   Enable the interrupt.
// Parameters:
//   hPMAC [in] handle to the card as received from PMAC_Open.
//   funcIntHandler [in] The call back function to be called upon interrupt.
// Return Value:
//   TRUE if the interrupt was successfully enabled. FALSE otherwise.
BOOL PMAC_IntEnable (PMAC_HANDLE hPMAC, PMAC_INT_HANDLER funcIntHandler)
{
    DWORD dwStatus;

    // Check if interrupt is already enabled
    if (hPMAC->Int.hThread)
        return FALSE;

    // Calls WD_IntEnable() and creates an interrupt handler thread
    hPMAC->Int.funcIntHandler = funcIntHandler;
    dwStatus = InterruptEnable(&hPMAC->Int.hThread, hPMAC->hWD, &hPMAC->Int.Int, PMAC_IntHandler, (PVOID) hPMAC);
    if (dwStatus)
    {
        sprintf(PMAC_ErrorString, "InterruptEnable() failed with status 0x%x - %s\n",
            dwStatus, Stat2Str(dwStatus));
        return FALSE;
    }

    return TRUE;
}

// Function: PMAC_IntDisable()
//   Disable the interrupt.
// Parameters:
//   hPMAC [in] handle to the card as received from PMAC_Open().
// Return Value:
//   None.
void PMAC_IntDisable (PMAC_HANDLE hPMAC)
{
    if (!hPMAC->Int.hThread) return;

    // this calls WD_IntDisable()
    InterruptDisable(hPMAC->Int.hThread);

    hPMAC->Int.hThread = NULL;
}

// Function: PMAC_RegisterEvent()
//   Register to receive Plug-and-Play and power notification events according to the given criteria.
// Parameters:
//   hPMAC [in] handle to the PCI card as received from PMAC_Open().
//   dwAction [in] bit-field data that indicated on what type of actions to be notified.
//   dwVendorID [in] indicates the vendor ID of the PCI card to register events upon.
//     0 indicates all vendor IDs.
//   dwDeviceID [in] indicates the device ID of the PCI card to register events upon.
//     0 indicates all device IDs.
//   pciSlot [in] indicates the logical location (bus, lot and function) of the PCI card
//     to register events upon. 0 indicates all
//   funcHandler [in] the call back function to be called when event is received.
// Return Value:
//   TRUE is the registration was successful. FALSE otherwise.
BOOL PMAC_RegisterEvent(PMAC_HANDLE hPMAC, DWORD dwAction, DWORD dwVendorID, DWORD dwDeviceID,
    WD_PCI_SLOT pciSlot, EVENT_HANDLER funcHandler)
{
    HANDLE hEvent;
    WD_EVENT Events;    DWORD dwStatus;

    BZERO(Events);
    Events.dwCardType = WD_BUS_PCI;
    Events.u.Pci.pciSlot = pciSlot;
    Events.u.Pci.cardId.dwVendorId = dwVendorID;
    Events.u.Pci.cardId.dwDeviceId = dwDeviceID;
    Events.dwAction = dwAction;
    dwStatus = EventRegister(&hEvent, hPMAC->hWD, &Events, funcHandler, NULL);
    if (dwStatus)
    {
        sprintf(PMAC_ErrorString, "EventRegister() failed with status 0x%x - %s\n",
            dwStatus, Stat2Str(dwStatus));
        return FALSE;
    }
    hPMAC->hEvent = hEvent;
    return TRUE;
}

// Function: PMAC_UnregisterEvent()
//   Unregister events notification.
// Parameters:
//   hPMAC [in] handle to the PCI card as received from PMAC_Open().
// Return Value:
//   None.
void PMAC_UnregisterEvent(PMAC_HANDLE hPMAC)
{
    if (hPMAC->hEvent)
        EventUnregister(hPMAC->hEvent);
}


// Returns a pointer to the PMAC base address
unsigned long *PMAC_GetBasePtr(PMAC_HANDLE hPMAC,PMAC_ADDR addrSpace)
{
	return((unsigned long *)hPMAC->cardReg.Card.Item[hPMAC->addrDesc[addrSpace].index].I.Mem.dwUserDirectAddr);
}

// Returns a pointer to the PMAC physical base address
unsigned long *PMAC_GetBasePtrPhysical(PMAC_HANDLE hPMAC,PMAC_ADDR addrSpace)
{
//	test using physical address: dwCpuPhysicalAddr
//	return((unsigned long *)hPMAC->cardReg.Card.Item[hPMAC->addrDesc[addrSpace].index].I.Mem.dwCpuPhysicalAddr);
//	test using physical address: dwPhysicalAddr
	return((unsigned long *)hPMAC->cardReg.Card.Item[hPMAC->addrDesc[addrSpace].index].I.Mem.dwPhysicalAddr);
	//	returned addresses equal in both cases. 
}
